var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// components/popover/popover.ts
import { LitElement, css, html, nothing } from "lit";
import { customElement, property, query } from "lit/decorators.js";

// components/shared/getFocusableElement.ts
var focusableItemMatcher = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
var getFocusableElements = (slot) => {
  const focusableElements = [
    ...slot.assignedElements().filter((slotChild) => slotChild.matches(focusableItemMatcher)),
    ...slot.assignedElements().flatMap((slotChild) => [...slotChild.querySelectorAll(focusableItemMatcher)])
  ];
  return focusableElements.filter(
    (element) => !element.hasAttribute("disabled") && !element.hasAttribute("aria-hidden")
  );
};

// components/shared/swipeAway.ts
var SwipeAway = class {
  constructor(host) {
    this.host = host;
    this.draggedElement = null;
    this.abortController = null;
    this.startYPos = null;
    this.prevEvent = null;
    this.velocity = 0;
    this.callbackFn = null;
    this.host.addController(this);
  }
  hostDisconnected() {
    this.abortController?.abort();
  }
  startSwipeAwayListener(el, callbackFn, opts) {
    this.abortController = new AbortController();
    this.callbackFn = callbackFn;
    this.draggedElement = el;
    const abortSignal = opts?.signal ? AbortSignal.any([opts.signal, this.abortController.signal]) : this.abortController.signal;
    const dragHandle = el.querySelector("[data-drag-handle]") ?? el;
    dragHandle.addEventListener("touchmove", (event) => this.onMouseMove(event), { signal: abortSignal });
    dragHandle.addEventListener("touchend", () => this.onMouseUp(), { signal: abortSignal });
  }
  onMouseMove(event) {
    event.preventDefault();
    const time = Date.now();
    const y = event.touches[0].screenY;
    this.velocity = this.prevEvent !== null ? (y - this.prevEvent.yPos) / (this.prevEvent.time - time) : 0;
    if (this.startYPos === null) {
      this.startYPos = y;
      this.draggedElement?.classList.add("dragging");
    }
    this.prevEvent = {
      yPos: y,
      time
    };
    if (this.draggedElement) {
      this.draggedElement.style.bottom = `${Math.min(0, this.startYPos - y)}px`;
    }
  }
  onMouseUp() {
    this.startYPos = null;
    if (this.draggedElement) {
      this.draggedElement.classList.remove("dragging");
      this.draggedElement.style.bottom = "0px";
    }
    if (this.velocity < -0.1) {
      this.abortController?.abort();
      this.callbackFn?.();
    }
    this.velocity = 0;
  }
};

// components/popover/popover.ts
var Popover = class extends LitElement {
  constructor() {
    super(...arguments);
    this.popoverAbortController = null;
    this.swiper = new SwipeAway(this);
    this.header = "";
    this.autofocus = false;
    this.isOpen = false;
  }
  onTriggerClick() {
    if (this.isOpen) {
      this.popoverElement.hidePopover();
    } else {
      this.popoverElement.showPopover();
    }
  }
  popoverToggle(event) {
    if (event.newState === "open") {
      this.popoverAbortController = new AbortController();
      this.isOpen = true;
      this.dispatchEvent(new CustomEvent("open", { bubbles: true, composed: true }));
      if (this.autofocus) {
        this.focusFirstElementInPopover();
      }
      this.listenForCloseClicks();
      this.swiper.startSwipeAwayListener(
        this.popoverElement,
        () => {
          this.popoverElement.hidePopover();
        },
        { signal: this.popoverAbortController.signal }
      );
    } else {
      this.popoverAbortController?.abort();
      this.triggerWrapper.assignedElements()[0].focus();
      this.isOpen = false;
      this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
    }
  }
  focusFirstElementInPopover() {
    const focusableElements = getFocusableElements(this.dialogContent);
    if (focusableElements.length) {
      focusableElements.at(0).focus();
    }
  }
  listenForCloseClicks() {
    const closeTriggers = this.dialogContent.assignedElements({ flatten: true }).flatMap((child) => Array.from(child.querySelectorAll("[data-cx-popover-close]")));
    closeTriggers.forEach((element) => {
      element.addEventListener("click", () => this.popoverElement.hidePopover(), {
        signal: this.popoverAbortController?.signal
      });
    });
  }
  onTouchMove(event) {
    event.preventDefault();
  }
  render() {
    const header = this.header ? html`
      <header>
        <h1>${this.header}</h1>
      </header>` : nothing;
    return html`
      <slot class="trigger" name="trigger" @click=${this.onTriggerClick}></slot>

      <div role="dialog" popover @toggle=${this.popoverToggle} @touchmove=${this.onTouchMove}>
        <div class="drag-handle" data-drag-handle>
          <div class="pill"></div>
        </div>

        ${header}
        <slot id="dialog-content"></slot>
      </div>
    `;
  }
};
Popover.styles = [
  css`
      .trigger {
        anchor-name: --trigger;
        display: inline-flex;
      }

      header {
        margin-bottom: var(--cx-spacing-4);
      }

      h1 {
        /** From typography */
        margin: 0;
        font-family: inherit;
        font-weight: 600;
        font-size: 1.125rem;
        line-height: 1.6rem;
        color: var(--cx-color-text-primary);
      }

      [popover] {
        --translate-curve: ease;
        --translate-duration: 200ms;
        --bottom-transition-duration: 200ms;
        
        position-anchor: --trigger;
        box-sizing: border-box;
        position: absolute;
        opacity: 0;
        translate: 0px 6px;
        inset: unset;
        margin: var(--cx-spacing-2) 0 0 0;
        position-area: bottom span-right;
        position-try: --bottom-left, --top-right, --top-left, --center-right, --center-left;
        transition:
          display 200ms allow-discrete,
          overlay 200ms allow-discrete,
          opacity 200ms ease,
          translate var(--translate-duration) var(--translate-curve),
          bottom var(--bottom-transition-duration) ease;
        background: var(--cx-color-background-primary);
        border: 1px solid var(--cx-color-border-primary);
        border-radius: var(--cx-radius-medium);
        max-height: 500px;
        padding: var(--cx-spacing-6) var(--cx-spacing-8);

        &::backdrop {
          opacity: 0;

          transition:
            display 300ms allow-discrete,
            overlay 300ms allow-discrete,
            opacity 300ms ease;
        }

        &:popover-open {
          --translate-curve: var(--ease-spring-3);
          --translate-duration: 500ms;
          opacity: 1;
          translate: 0px;

          &::backdrop {
            opacity: 1;
          }

          @starting-style {
            opacity: 0;
            translate: 0px -6px;

            &::backdrop {
              opacity: 0;
            }
          }
        }

        @media (pointer: coarse) {
          position: fixed;
          inset: auto 0 0 0;
          border-bottom-width: 0px;
          translate: 0px 100%;
          position-anchor: unset;
          margin: 0;
          width: 100vw;
          border-radius: var(--cx-radius-medium) var(--cx-radius-medium) 0 0;
          min-height: 200px;

          &::backdrop {
            background-color: var(--cx-color-background-backdrop);
          }

          &:popover-open {
            --translate-curve: var(--ease-out-5);

            @starting-style {
              opacity: 0.5;
              translate: 0px 100%;
            }
          }

          .drag-handle {
            display: flex;
          }
        }

        &.dragging {
          --bottom-transition-duration: 0ms;
        }
      }

      .drag-handle {
        display: none;
        justify-content: center;
        padding-block: 16px;
        margin-top: -16px;
        
        .pill {
          height: var(--cx-spacing-1);
          width: var(--cx-spacing-10);
          border-radius: var(--cx-radius-pill);
          background: var(--cx-color-border-soft);
        }
      }

      @position-try --bottom-left {
        position-area: bottom span-left;
        margin: var(--cx-spacing-2) 0 0 0;
      }

      @position-try --top-right {
        position-area: top span-right;
        margin: 0 0 var(--cx-spacing-2) 0;
      }

      @position-try --top-left {
        position-area: top span-left;
        margin: 0 0 var(--cx-spacing-2) 0;
      }

      @position-try --center-right {
        position-area: span-bottom right;
        margin: 0 0 0 var(--cx-spacing-2);
      }

      @position-try --center-left {
        position-area: span-bottom left;
        margin: 0 var(--cx-spacing-2) 0 0;
      }
  `
];
__decorateClass([
  property({ type: String, reflect: true })
], Popover.prototype, "header", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], Popover.prototype, "autofocus", 2);
__decorateClass([
  query("[popover]")
], Popover.prototype, "popoverElement", 2);
__decorateClass([
  query("#dialog-content")
], Popover.prototype, "dialogContent", 2);
__decorateClass([
  query('slot[name="trigger"]')
], Popover.prototype, "triggerWrapper", 2);
Popover = __decorateClass([
  customElement("cx-popover")
], Popover);
export {
  Popover
};
//# sourceMappingURL=index.js.map
