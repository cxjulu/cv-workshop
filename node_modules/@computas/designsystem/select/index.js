var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// components/select/select.ts
import { LitElement, css, html } from "lit";
import { customElement, property, query, state } from "lit/decorators.js";
import { classMap } from "lit/directives/class-map.js";
import "../icon";

// components/shared/formControl.ts
var FormControl = (superClass) => {
  class FormControlClass extends superClass {
    static {
      /**
       * This is a magic prop that identifies the element
       * as a form-associated custom element.
       **/
      this.formAssociated = true;
    }
    get label() {
      return this.elementInternals.labels;
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    constructor(...args) {
      super(...args);
      this.elementInternals = this.attachInternals();
    }
  }
  return FormControlClass;
};

// components/select/select.ts
var Select = class extends FormControl(LitElement) {
  constructor() {
    super(...arguments);
    this.value = "";
    this.required = false;
    this["aria-describedby"] = "";
    this.selectOptions = [];
    this.isExpanded = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("option-select", this.setNewValue);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("option-select", this.setNewValue);
  }
  onSlotChange(event) {
    const slot = event.target;
    const tabContent = slot.assignedElements({ flatten: true });
    this.selectOptions = tabContent;
  }
  onPopoverToggle(event) {
    if (event.newState === "open") {
      this.isExpanded = true;
      this.addEventListener("keydown", this.onKeyDown);
      if (this.value) {
        this.selectOptions.forEach((option) => {
          option.selectedValue = this.value;
          if (option.value === this.value) {
            option.buttonElement.focus();
            option.buttonElement.tabIndex = 0;
          } else {
            option.buttonElement.tabIndex = -1;
          }
        });
      } else {
        this.selectOptions.forEach((option, index) => {
          if (index === 0) {
            option.buttonElement.focus();
            option.buttonElement.tabIndex = 0;
          } else {
            option.buttonElement.tabIndex = -1;
          }
        });
      }
    } else {
      this.removeEventListener("keydown", this.onKeyDown);
      this.isExpanded = false;
      this.updateValidState();
    }
  }
  onTriggerKeyDown(event) {
    if (event.key === "ArrowDown" && !this.isExpanded) {
      event.preventDefault();
      this.popoverElement.showPopover();
    }
  }
  updateValidState() {
    if (!this.isExpanded && this.required && !this.value) {
      this.selectTrigger.setCustomValidity("A value is required");
      this.elementInternals.setValidity({ valueMissing: true }, "A value is required");
    } else {
      this.selectTrigger.setCustomValidity("");
      this.elementInternals.setValidity({});
    }
  }
  onKeyDown(event) {
    const currentIndex = this.selectOptions.findIndex((option) => option.buttonElement.tabIndex === 0);
    const currentFocusedButton = this.selectOptions.at(currentIndex)?.buttonElement;
    if (currentFocusedButton) {
      currentFocusedButton.tabIndex = -1;
    }
    let newIndex = currentIndex;
    if (["ArrowDown", "ArrowRight"].includes(event.key)) {
      event.preventDefault();
      newIndex = (currentIndex + 1) % this.selectOptions.length;
    } else if (["ArrowUp", "ArrowLeft"].includes(event.key)) {
      event.preventDefault();
      newIndex = (currentIndex - 1 + this.selectOptions.length) % this.selectOptions.length;
    } else if (event.code === `Key${event.key.toUpperCase()}`) {
      event.preventDefault();
      const firstMatchIndex = this.selectOptions.findIndex(
        (opt) => opt.innerText.toLowerCase().startsWith(event.key.toLowerCase())
      );
      newIndex = firstMatchIndex === -1 ? currentIndex : firstMatchIndex;
    } else if (event.key === "Tab") {
      this.popoverElement.hidePopover();
    } else if (event.key === "Escape") {
      this.popoverElement.hidePopover();
      this.selectTrigger.focus();
    }
    const newFocusedButton = this.selectOptions.at(newIndex)?.buttonElement;
    if (newFocusedButton) {
      newFocusedButton.tabIndex = 0;
      newFocusedButton.focus();
    }
  }
  setNewValue(newValueEvent) {
    const newValue = newValueEvent.detail.value;
    const event = new CustomEvent("change", { bubbles: true, composed: true, detail: { value: newValue } });
    this.dispatchEvent(event);
    this.value = newValue;
    this.selectOptions.forEach((opt) => {
      opt.selectedValue = newValue;
    });
    this.updateValidState();
    this.elementInternals.setFormValue(newValue);
    this.popoverElement.hidePopover();
    this.selectTrigger.focus();
  }
  /**
   * We need to stop click events on the popover, since they will bubble to the
   * label element that wraps the select-component and trigger an "showPopover" event.
   */
  stopOptionClickEventPropagation(event) {
    event.stopPropagation();
  }
  render() {
    const selectedOption = this.selectOptions.find((option) => option.value === this.value);
    return html`
      <button 
        class="trigger" 
        popovertarget="popover"
        role="combobox"
        aria-haspopup="listbox"
        aria-expanded=${this.isExpanded}
        aria-controls="popover"
        aria-describedby=${this["aria-describedby"]}
        id=${this.id}
        required=${this.required}
        value=${this.value}
        @keydown=${this.onTriggerKeyDown}
        @blur=${this.updateValidState}
      >
        <span class="trigger-content" .innerHTML=${selectedOption?.innerHTML ?? ""}></span>
        <cx-icon name="down" class=${classMap({ rotated: this.isExpanded })}></cx-icon>
      </button>

      <div
        role="listbox"
        popover
        @toggle=${this.onPopoverToggle}
        id="popover"
        aria-multiselectable="false"
        @click=${this.stopOptionClickEventPropagation}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </div>
    `;
  }
};
// `delegateFocus` allows focus to be passed to the select trigger when placed inside a `<label>` element.
Select.shadowRootOptions = { ...LitElement.shadowRootOptions, delegatesFocus: true };
Select.styles = css`
    .trigger {
      anchor-name: --cx-trigger;

      border: none;
      background-color: transparent;
      padding: var(--cx-form-field__block-padding) var(--cx-form-field__inline-padding);
      width: 100%;
      min-width: 200px;

      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--cx-spacing-2);
      cursor: inherit;
      
      color: var(--cx-color-text-primary);
      font: inherit;
      font-size: 1rem;
      font-weight: 400;
      outline: none;
    }

    cx-icon {
      transition: rotate 200ms ease;

      &.rotated {
        rotate: 180deg;
      }
    }

    .trigger-content {
      display: flex;
      align-items: center;
      gap: var(--cx-spacing-2);
      line-height: 1rem;
    }

    [popover] {
      --translate-curve: ease;
      --translate-duration: 200ms;

      position-anchor: --cx-trigger;
      position: absolute;
      opacity: 0;
      translate: 0px 6px;
      inset: unset;
      left: anchor(left);
      top: anchor(bottom);
      margin-block: var(--cx-spacing-2);
      position-try-fallbacks: --top;
      width: anchor-size(width);
      transition:
        display 200ms allow-discrete,
        overlay 200ms allow-discrete,
        opacity 200ms ease,
        translate var(--translate-duration) var(--translate-curve);
      border: 1px solid var(--cx-color-border-primary);
      background: var(--cx-color-background-primary);
      border-radius: var(--cx-radius-medium);
      padding: 0;

      &:popover-open {
        --translate-curve: var(--ease-spring-3);
        --translate-duration: 500ms;
        opacity: 1;
        translate: 0px;

        @starting-style {
          opacity: 0;
          translate: 0px -6px;
        } 
      }
    }

    @position-try --top {
      top: unset;
      bottom: anchor(top);
    }
  `;
__decorateClass([
  property({ type: String, reflect: true })
], Select.prototype, "value", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], Select.prototype, "required", 2);
__decorateClass([
  property({ type: String, reflect: true })
], Select.prototype, "aria-describedby", 2);
__decorateClass([
  state()
], Select.prototype, "selectOptions", 2);
__decorateClass([
  state()
], Select.prototype, "isExpanded", 2);
__decorateClass([
  query("button")
], Select.prototype, "selectTrigger", 2);
__decorateClass([
  query("[popover]")
], Select.prototype, "popoverElement", 2);
Select = __decorateClass([
  customElement("cx-select")
], Select);

// components/select/option.ts
import { LitElement as LitElement2, css as css2, html as html2 } from "lit";
import { customElement as customElement2, property as property2, query as query2, state as state2 } from "lit/decorators.js";
import { classMap as classMap2 } from "lit/directives/class-map.js";

// components/shared/inputModeDetector.ts
var InputModeDetector = class {
  constructor(host) {
    this.host = host;
    this.abortMouseListener = new AbortController();
    this.abortKeydownListener = new AbortController();
    /** We start by assuming keyboard is main input mode */
    this.inputMode = "keyboard";
    this.host.addController(this);
  }
  hostConnected() {
    document.addEventListener("mousemove", () => this.setMouseInputMode(), {
      signal: this.abortMouseListener.signal
    });
  }
  hostDisconnected() {
    this.abortMouseListener.abort();
    this.abortKeydownListener.abort();
  }
  setMouseInputMode() {
    if (this.inputMode !== "mouse") {
      this.inputMode = "mouse";
      this.host.requestUpdate();
      this.abortMouseListener.abort();
      this.abortKeydownListener = new AbortController();
      document.addEventListener("keydown", () => this.setKeyboardInputMode(), {
        signal: this.abortKeydownListener.signal
      });
    }
  }
  setKeyboardInputMode() {
    if (this.inputMode !== "keyboard") {
      this.inputMode = "keyboard";
      this.host.requestUpdate();
      this.abortKeydownListener.abort();
      this.abortMouseListener = new AbortController();
      document.addEventListener("mousemove", () => this.setMouseInputMode(), {
        signal: this.abortMouseListener.signal
      });
    }
  }
};

// components/select/option.ts
var Option = class extends LitElement2 {
  constructor() {
    super(...arguments);
    this.selectedValue = "";
    this.value = null;
    this.inputModeDetector = new InputModeDetector(this);
  }
  onSelect() {
    const event = new CustomEvent("option-select", {
      bubbles: true,
      composed: true,
      detail: { value: this.value }
    });
    this.dispatchEvent(event);
  }
  render() {
    const isSelected = !!this.selectedValue && this.selectedValue === this.value;
    return html2`
      <button
        role="option"
        @click=${this.onSelect}
        aria-selected=${isSelected}
        class=${classMap2({ active: isSelected, "input-mode-mouse": this.inputModeDetector.inputMode === "mouse" })}
      >
        <slot></slot>
      </button>
    `;
  }
};
Option.styles = [
  css2`
      button {
        --cx-gradient-highlight: var(--cx-color-background-primary);
        --cx-gradient-background: var(--cx-color-background-primary);

        display: flex;
        gap: var(--cx-spacing-2);
        align-items: center;
        color: var(--cx-color-text-primary);
        border: none;
        padding: var(--cx-spacing-5) var(--cx-spacing-6);
        line-height: 1rem;
        font-family: inherit;
        font-size: 0.875rem;
        font-weight: 400;
        width: 100%;
        background-image: linear-gradient(62deg, var(--cx-gradient-highlight) 28.33%, var(--cx-gradient-background) 127.11%);
        transition: 200ms ease;
        transition-property: color, --cx-gradient-highlight, --cx-gradient-background;

        &:where(:focus, :hover) {
          outline: none;
        }

        &:not(:disabled) {
          cursor: pointer;

          &:is(:not(.input-mode-mouse):focus, .input-mode-mouse:hover) {
            --cx-gradient-highlight: var(--cx-color-grey-700);
            --cx-gradient-background: var(--cx-color-blue);
            color: var(--cx-color-text-static-light);
          }
        }

        &.active {
          --cx-gradient-highlight: var(--cx-color-background-accent-5);
          --cx-gradient-background: var(--cx-color-background-accent-5);
        }
      }
    `
];
__decorateClass([
  state2()
], Option.prototype, "selectedValue", 2);
__decorateClass([
  property2({ type: String, reflect: true })
], Option.prototype, "value", 2);
__decorateClass([
  query2("button")
], Option.prototype, "buttonElement", 2);
Option = __decorateClass([
  customElement2("cx-option")
], Option);
export {
  Option,
  Select
};
//# sourceMappingURL=index.js.map
